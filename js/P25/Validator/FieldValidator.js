const weakKeysDes = [
    // des weak keys (4)
    [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01],
    [0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE],
    [0xE0, 0xE0, 0xE0, 0xE0, 0xF1, 0xF1, 0xF1, 0xF1],
    [0x1F, 0x1F, 0x1F, 0x1F, 0x0E, 0x0E, 0x0E, 0x0E],
    // des semi weak keys (12)
    [0x01, 0x1F, 0x01, 0x1F, 0x01, 0x0E, 0x01, 0x0E],
    [0x1F, 0x01, 0x1F, 0x01, 0x0E, 0x01, 0x0E, 0x01],
    [0x01, 0xE0, 0x01, 0xE0, 0x01, 0xF1, 0x01, 0xF1],
    [0xE0, 0x01, 0xE0, 0x01, 0xF1, 0x01, 0xF1, 0x01],
    [0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE],
    [0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01],
    [0x1F, 0xE0, 0x1F, 0xE0, 0x0E, 0xF1, 0x0E, 0xF1],
    [0xE0, 0x1F, 0xE0, 0x1F, 0xF1, 0x0E, 0xF1, 0x0E],
    [0x1F, 0xFE, 0x1F, 0xFE, 0x0E, 0xFE, 0x0E, 0xFE],
    [0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x0E, 0xFE, 0x0E],
    [0xE0, 0xFE, 0xE0, 0xFE, 0xF1, 0xFE, 0xF1, 0xFE],
    [0xFE, 0xE0, 0xFE, 0xE0, 0xFE, 0xF1, 0xFE, 0xF1],
    // des possibly weak keys (48)
    [0x01, 0x01, 0x1F, 0x1F, 0x01, 0x01, 0x0E, 0x0E],
    [0x01, 0x01, 0xE0, 0xE0, 0x01, 0x01, 0xF1, 0xF1],
    [0x01, 0x01, 0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE],
    [0x01, 0x1F, 0x1F, 0x01, 0x01, 0x0E, 0x0E, 0x01],
    [0x01, 0x1F, 0xE0, 0xFE, 0x01, 0x0E, 0xF1, 0xFE],
    [0x01, 0x1F, 0xFE, 0xE0, 0x01, 0x0E, 0xFE, 0xF1],
    [0x01, 0xE0, 0x1F, 0xFE, 0x01, 0xF1, 0x0E, 0xFE],
    [0xFE, 0x01, 0xE0, 0x1F, 0xFE, 0x01, 0xF1, 0x0E],
    [0x01, 0xE0, 0xE0, 0x01, 0x01, 0xF1, 0xF1, 0x01],
    [0x01, 0xE0, 0xFE, 0x1F, 0x01, 0xF1, 0xFE, 0x0E],
    [0x01, 0xFE, 0x1F, 0xE0, 0x01, 0xFE, 0x0E, 0xF1],
    [0x01, 0xFE, 0xE0, 0x1F, 0x01, 0xFE, 0xF1, 0x0E],
    [0x01, 0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x01],
    [0x1F, 0x01, 0x01, 0x1F, 0x0E, 0x01, 0x01, 0x0E],
    [0x1F, 0x01, 0xE0, 0xFE, 0x0E, 0x01, 0xF1, 0xFE],
    [0x1F, 0x01, 0xFE, 0xE0, 0x0E, 0x01, 0xFE, 0xF1],
    
    [0x1F, 0x1F, 0x01, 0x01, 0x0E, 0x0E, 0x01, 0x01],
    [0x1F, 0x1F, 0xE0, 0xE0, 0x0E, 0x0E, 0xF1, 0xF1],
    [0x1F, 0x1F, 0xFE, 0xFE, 0x0E, 0x0E, 0xFE, 0xFE],
    [0x1F, 0xE0, 0x01, 0xFE, 0x0E, 0xF1, 0x01, 0xFE],
    [0x1F, 0xE0, 0xE0, 0x1F, 0x0E, 0xF1, 0xF1, 0x0E],
    [0x1F, 0xE0, 0xFE, 0x01, 0x0E, 0xF1, 0xFE, 0x01],
    [0x1F, 0xFE, 0x01, 0xE0, 0x0E, 0xFE, 0x01, 0xF1],
    [0x1F, 0xFE, 0xE0, 0x01, 0x0E, 0xFE, 0xF1, 0x01],
    [0x1F, 0xFE, 0xFE, 0x1F, 0x0E, 0xFE, 0xFE, 0x0E],
    [0x1F, 0xFE, 0xFE, 0x1F, 0x0E, 0xFE, 0xFE, 0x0E],
    [0xE0, 0x01, 0x1F, 0xFE, 0xF1, 0x01, 0x0E, 0xFE],
    [0xE0, 0x01, 0xFE, 0x1F, 0xF1, 0x01, 0xFE, 0x0E],
    [0xE0, 0x1F, 0x01, 0xFE, 0xF1, 0x0E, 0x01, 0xFE],
    [0xE0, 0x1F, 0x1F, 0xE0, 0xF1, 0x0E, 0x0E, 0xF1],
    [0xE0, 0x1F, 0xFE, 0x01, 0xF1, 0x0E, 0xFE, 0x01],
    [0xE0, 0xE0, 0x01, 0x01, 0xF1, 0xF1, 0x01, 0x01],
    
    [0xE0, 0xE0, 0x1F, 0x1F, 0xF1, 0xF1, 0x0E, 0x0E],
    [0xE0, 0xE0, 0xFE, 0xFE, 0xF1, 0xF1, 0xFE, 0xFE],
    [0xE0, 0xFE, 0x01, 0x1F, 0xF1, 0xFE, 0x01, 0x0E],
    [0xE0, 0xFE, 0x1F, 0x01, 0xF1, 0xFE, 0x0E, 0x01],
    [0xE0, 0xFE, 0xFE, 0xE0, 0xF1, 0xFE, 0xFE, 0xF1],
    [0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x01, 0x01, 0xFE],
    [0xFE, 0x01, 0x1F, 0xE0, 0xFE, 0x01, 0x0E, 0xF1],
    [0xFE, 0x1F, 0x01, 0xE0, 0xFE, 0x0E, 0x01, 0xF1],
    [0xFE, 0x1F, 0xE0, 0x01, 0xFE, 0x0E, 0xF1, 0x01],
    [0xFE, 0x1F, 0x1F, 0xFE, 0xFE, 0x0E, 0x0E, 0xFE],
    [0xFE, 0xE0, 0x01, 0x1F, 0xFE, 0xF1, 0x01, 0x0E],
    [0xFE, 0xE0, 0x1F, 0x01, 0xFE, 0xF1, 0x0E, 0x01],
    [0xFE, 0xE0, 0xE0, 0xFE, 0xFE, 0xF1, 0xF1, 0xFE],
    [0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x01, 0x01],
    [0xFE, 0xFE, 0x1F, 0x1F, 0xFE, 0xFE, 0x0E, 0x0E],
    [0xFE, 0xFE, 0xE0, 0xE0, 0xFE, 0xFE, 0xF1, 0xF1]
];
const guessableKeysDes = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07],
    [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF]
];
const guessableKeysAes = [
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ],
    [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
    ],
    [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
        0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF
    ]
];
const guessableKeysAdp = [
    [0x00, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x01, 0x02, 0x03, 0x04],
    [0x01, 0x23, 0x45, 0x67, 0x89]
];

function IsValidKeysetId(keysetId) {
    /* TIA 102.AACA-A 10.3.11 */
    if (keysetId < 0x01 || keysetId > 0xFF) {
        return false;
    }
    else {
        return true;
    }
}

function IsValidSln(sln) {
    /* TIA 102.AACA-A 10.3.25 */
    if (sln < 0x0000 || sln > 0xFFFF) {
        return false;
    }
    else {
        return true;
    }
}

function IsValidKeyId(keyId) {
    /* TIA 102.AACA-A 10.3.10 */
    if (keyId < 0x0000 || keyId > 0xFFFF) {
        return false;
    }
    else {
        return true;
    }
}

function IsValidAlgorithmId(algId) {
    /* TIA-102.BAAC-D 2.8 */
    if (algId < 0x00 || algId > 0xFF) {
        return false;
    }
    else {
        return true;
    }
}

function IsValidSingleDesKeyParity(key) {
    if (key.length != 8) {
        return false;
    }
    
    for (var index=0;index<key.length; index++) {
        let set = Boolean(key[index] & 0x01);// least significant bit is the parity bit

        let c = (key[index] & 0xFE);
        var tmp1 = ((c & 0xF) ^ (c >> 4));
        var tmp2 = ((tmp1 & 0x3) ^ (tmp1 >> 2));
        var sumBitsMod2 = ((tmp2 & 0x1) ^ (tmp2 >> 1));

        let calc = false;

        if (sumBitsMod2 == 0) {
            calc = true;
        }

        if (set != calc) {// parity bit is incorrect
            return false;
        }
    }
    return true;
}

function KeyloadValidate(keysetId, sln, keyId, algId, key) {
    if (!IsValidKeysetId(keysetId)) {
        return "Keyset ID invalid - valid range 1 to 255 (dec), 0x01 to 0xFF (hex)";
    }

    if (!IsValidSln(sln)) {
        return {status: "Error", message: "SLN invalid - valid range 0 to 65535 (dec), 0x0000 to 0xFFFF (hex)"};
    }

    if (!IsValidKeyId(keyId)) {
        return {status: "Error", message: "Key ID invalid - valid range 0 to 65535 (dec), 0x0000 to 0xFFFF (hex)"};
    }

    if (!IsValidAlgorithmId(algId)) {
        return {status: "Error", message: "Algorithm ID invalid - valid range 0 to 255 (dec), 0x00 to 0xFF (hex)"};
    }

    if (algId == AlgorithmId.CLEAR) {
        return {status: "Error", message: "Algorithm ID 0x80 is reserved for clear operation"};
    }

    else if (algId == AlgorithmId.ACCORDION ||
        algId == AlgorithmId.BATON_ODD ||
        algId == AlgorithmId.FIREFLY ||
        algId == AlgorithmId.MAYFLY ||
        algId == AlgorithmId.SAVILLE ||
        algId == AlgorithmId.PADSTONE ||
        algId == AlgorithmId.BATON_EVEN) {
            return {status: "Warning", message: "Algorithm ID 0x" + algId.toString(16).toUpperCase().padStart(2, "0") + " is a Type 1 algorithm - no key validation has been performed"};
    }
    else if (algId == AlgorithmId.DESOFB || algId == AlgorithmId.DESXL) {
        if (key.length != 8) {
            return {status: "Error", message: "Key length invalid - expected 8 bytes, got " + key.length + " bytes"};
        }

        if (!IsValidSingleDesKeyParity(key)) {
            return {status: "Error", message: "Key parity invalid"};
        }

        // des weak keys per NIST SP 800-67 Rev 2 3.3.2
        for (let keyComp of weakKeysDes) {
            if ((key.every((value, index) => value === keyComp[index]))) {
                return {status: "Warning", message: "This key is cryptographically weak"};
            }
        }

        for (let keyComp of guessableKeysDes) {
            if ((key.every((value, index) => value === keyComp[index]))) {
                return {status: "Warning", message: "This key is easily guessable"};
            }
        }
    }
    else if (algId == AlgorithmId.AES256) {
        if (key.length != 32) {
            return {status: "Error", message: "Key length invalid - expected 32 bytes, got " + key.length + " bytes"};
        }

        for (let keyComp of guessableKeysAes) {
            if ((key.every((value, index) => value === keyComp[index]))) {
                return {status: "Warning", message: "This key is easily guessable"};
            }
        }
    }
    else if (algId == AlgorithmId.ADP) {
        if (key.length != 5) {
            return {status: "Error", message: "Key length invalid - expected 5 bytes, got " + key.length + " bytes"};
        }
        for (let keyComp of guessableKeysAdp) {
            if ((key.every((value, index) => value === keyComp[index]))) {
                return {status: "Warning", message: "This key is easily guessable"};
            }
        }
    }
    else {// all other algorithm IDs
        return {status: "Warning", message: "Algorithm ID 0x" + algId.toString(16).toUpperCase().padStart(2, "0") + " is unassigned - no key validation has been performed"};
    }

    // good practice validators
    if (sln == 0x00) {
        return {status: "Warning", message: "While the SLN 0 is valid, some equipment may have issues using it"}; // *cough* Motorola KVLs *cough*
    }
    else if (sln > 0x0FFF && sln < 0xF000) {
        return {status: "Warning", message: "While this SLN is valid, it uses a crypto group other than 0 or 15, some equipment may have issues using it"};
    }

    return {status: "Success", message: ""};
}